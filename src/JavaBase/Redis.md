# 概述
 - Redis 是速度非常快的非关系型内存键值数据库 可以存储键和五种不同类型的值之间的映射。键的类型只能是字符串 
 值支持的五种类型数据类型为：字符串，列表，集合，有序集合，散列表。
 - Redis 支持很多特性 将内存中的数据持久到硬盘中 使用复制来扩展读性能 使用分片来扩展写性能
 # 数据类型
  数据类型 | 可以存储的值 | 操作
  ---|:---:|:---
  String | 字符串，整数或者浮点数 | 对整个字符串或者字符串的一部分操作对\n 整数和浮点数执行自增或者自减操作
  LIST | 列表 | 从两端压入或者弹出元素 读取单个或者多个元素 进行修剪 只保留一个范围内的元素
  SET | 无序集合 | 添加，获取，移除单个元素 检查一个元素是否存在于集合中 计算交集 并集 差集 从集合里边随机获取元素
  HASH | 包含键值对的无序散列表 | 添加 获取 移除单个键值对获取所有键值对检查某个键是否存在
  ZSET | 有序集合 | 添加 获取 删除元素 根据分值范围或者成员来获取元素计算一个键的排名
 
 ##数据操作
 数据类型 | 数据操作
 ---|:---
 STRING | set, get, del
 LIST | rpush,lrange,lindex,lpop 
 SET | sadd , smembers , srem , sismember
 HASH  | hset,hgetall,hdel
 ZSET | zadd, zrange,zrangebyscore ,zrem
 
 # 数据结构
 ## 跳跃表 
 - 是有序集合的底层实现之一 跳跃表是基于多指针有序链表实现的 可以看成多个有序链表
 - 哈希表 
 # 使用场景
 ## 计数器
 - 可以对String进行自增自减运算 从而实现计数器的功能 例如对于网站访问量 如果使用mysql 数据库进行存储 那么每访问一次网站
 就要对磁盘进行读写操作 而redis这种内存型数据库的读写性能非常高 很适合存储这种频繁读写的计数量。
 ## 缓冲
 - 将热点数据放在内存中 设置内存的最大使用量 以及淘汰策略来保证缓存的命中率
 ## 查找表
 - 例如DNS记录就适合Redis进行存储 查找表和缓存类似 也是利用了Redis快速的查找特性
  但是查找表的内容不能失效 而缓存的内容可以失效
  ## 消息队列
  - List是一个双向链表 通过lpop 和lpush 写入和读取消息
  不过最好是使用kafka RabbitMQ等消息中间件
  ## 会话缓存
  - 在分布式场景下具有多个应用服务器 可以使用Redis来统一存储这些应用服务器的会话信息 使得某个应用服务器宕机时不会
  丢失会话信息 从而保证高可用
  ## 分布式锁实现
  - 在分布式场景下 无法使用单机环境下的锁实现 当多个节点上的进程都需要获取同一个锁时 就需要使用分布式锁来进行同步
  除了可以使用Redis自带SETNX命令实现分布式之后 还可以使用官方提供的RedLock分布式实现
  ## 其他
  - Set 可以实现交集 并集等操作 例如共同好友功能
  - Zset可以实现有序性操作 例如排行榜功能
  
  # Redis 与 Memcached
    两者都是非关系型内存键值数据库 有以下主要不同
  ## 数据类型
  Memcached 仅支持字符串类型 而Redis支持五种不同不同的数据类型, 使得它可以更灵活地解决问题
  ## 数据持久化
  Redis 支持两种持久化策略: RDB快照和AOP日志 而Mencachced不支持持久化
  ## 分布式 
  Memcached 不支持分布式 只能通过在客户端使用一致性哈希这样吃的分布式算法来实现分布式存储 这种方式在存储和查询是都需要
  先在客户端计算一次数据所在的节点
  ## 内存管理机制
  在redis中 并不是所有的珊瑚橘都一直存储在内存中 可以将一些很久没有的value交换到磁盘 而memcached的
  数据则会一直内存中。
  Memcached 将内存分割成特定长度的块来存储数据 以完全解决内存碎片的问题 但是这种方式会使得内存的利用率不高
  例如块的大小为128 bytes 只存储100bytes的数据 那么剩下的28 bytes 浪费了。
  
  # 键的过期时间
  Redis 可以为每个键设置过期时间 当键过期时 会自动删除该键
  对于散列表这种容器 只能为整个键设置过期时间（整个散列表）而不能为键里面的单个元素设置过期时间
  
  # 数据淘汰策略
  可以设置内存最大使用量 当内存使用量草果是实行淘汰策略 具体有六种淘汰策略
  
  策略 | 描述 
  ---|:---
  volatile-lru | 从已设置过期时间的数据集中 挑选最近最少使用的数据淘汰
  volatile--ttl | 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  volatile-random | 从已设置过期的数据集中任意选择数据淘汰
  allkeys-lru  | 从所有数据集中挑选最近最少使用的数据淘汰
  allkeys-random | 从所有数据集中任意选择数据进行淘汰
  noeviction | 禁止驱逐数据
  
  如果使用redis来缓存数据时 要保证所有的数据都是热点数据 可以将内存最大使用量设置为热点数据占用的内存量 
  然后启用allkeys-lru 淘汰策略将最近使用的数据淘汰

作为内存数据库 出于对性能和内存消耗的考虑 redis的淘汰算法（LRU,TTL）实际实现上并非针对所有的key 而是抽样
一部分key从中选出被淘汰的key

# 持久化
Redis是内存型数据库 为了保存数据在断电后不会丢失 需要将内存中的数据持久化到磁盘上

## 快照持久化
- 将某个时间点的所有数据都存放到硬盘上
- 可以将快照复制到其他服务器从而创建具有相同数据的服务器副本
- 如果系统发生故障 将会丢失最后一次创建快照之后的数据
- 如果数据量很大 保存快照的时间会很长

## AOP持久化
    将写命令添加到AOF文件的末尾
    对硬盘的文件进行写入时 写入的内容首先会被缓存到缓冲区 然后又操作系统决定什么时候将该内容同步到硬盘
    用户可以调用file.fush() 方法请求操作系统尽快将缓存的数据同步到硬盘 可以看出写入文件的数据不会立即同步到硬盘上
    在将写命令添加到AOF文件时 要根据需求来保证何时同步到硬盘上
    
    有以下同步选项：
    
   选项|同步频率 
   ---|:---
    always | 每个写命令都同步  
    everysec | 每秒同步一次
    no | 让操作系统来决定何时同步
    
   - 
    




  
  
 
 
 
 
 