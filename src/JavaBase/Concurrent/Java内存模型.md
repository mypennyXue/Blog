#Java 内存模型

- java内存模型试图屏蔽各种硬件和操作系统的内存访问差异 以实现让Java程序在各种平台下都能达到一致的内存访问效果

## 主内存与工作内存
- 处理器上的寄存器的读写速度比内存快几个数量级 为了解决这种速度矛盾 在他们之间加入了高速缓存
加入了高速缓存带来了一个新的问题：缓存一致性 如果多个缓存共享同一块主内存区域 那么多个缓存的数据可能会不一致
需要一些协议来解决这个问题

- 所有的变量都存储在主内存中 每个线程还有自己的工作内存 工作内存存储在高速缓存或者寄存器中 保存了该线程使用的
变量的主内存副本拷贝

- 线程只能直接操作工作内存中的变量 不同线程间的变量值传递需要通过主内存来完成

## 内存间交互操作
- read: 把一个变量的值从主内存传输到工作内存中
- load: 在read之后执行 把read得到的值放入工作内存的变量副本中
- use: 把工作内存中的一个变量的值传递给执行引擎
- assign: 把一个从执行引擎接受到的值赋给工作内存的变量
- store: 把工作内存的一个变量的值传送到主内存中
- write: 在store之后执行 把store得到的值放入到主内存的变量中
- lock: 作用于主内存中的变量
- unlock

## 内存模型的三大特性
### 原子性
### 可见性
- 可见性指当一个线程修改了共享变量的值 其他线程能够立即得知这个修改 Java内存模型是通过在变量修改后将新值同步回主内存
,在变量读取前从主内存刷新变量值来实现可见性的
- 主要有三种实现可见性的方式
    - Volaile 
    - synchronized 对一个变量执行unlock操作前 必须把变量值同步回主内存
    - final 被final关键字修饰的字段在构造器中一旦初始化完成 并且没有发生this逃逸（其他线程通过this引用
    访问到初始化了一半的对象），那么其他线程就能看见final字段的值
### 有序性
- 有序性指: 在本程序内观察 所有的操作都是有序的额，在一个线程观察另一个线程 所有的操作都是无序的 无序是因为发生了
指令重排序
- 在java内存模型中 允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响多线程并发
执行的正确性
- volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前
- 也可以通过synchronized 来保证有序性 它保证每个时刻只有一个线程执行同步代码 相当于是让线程顺序执行同步代码

## 先行发生原则
 ### 单一线程原则
 - 在一个线程内 在程序前面的操作先行发生于后面的操作
 ### 管程锁定规则
 - 一个unlock操作先行发生于后面对同一个锁的lock操作
 ### volatile 变量规则
 对一个volatile变量的写操作先行发生于后面对这个变量的读操作
 ### 线程启动规则
 thread对象的start方法调用先行发生于此线程的而每一个动作
 ### 线程加入规则
 Thread 对象的结束先行发生于join()方法返回
 ### 线程中断规则
 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupt()方法
 检测到是否有中断发生
 ### 对象终结规则
 一个对象的初始化完成 （构造函数执行结束）先行发生于5它的finalize()方法的开始
 ### 传递性
 如果操作A先行发生于操作B ,操作B先行发生于操作C，那么操作A先行发生于操作C