# Spring
## Spring 事务
### 传播行为
传播行为 | 意义
---:|:---
PROPERGATION_MANDATORy | 表示方法必须运行在一个事务中 如果 当前事务不存在 就抛出异常
PROPERGATION_NESTED | 表示如果当前事务存在 则方法应该运行在一个嵌套的事务中 否则，它看起来和PROPERGATION_REQUIRED看起来没什么两样
PROPERGATION_NEVER | 表示方法不能运行在一个事务中，否则抛出异常
PROPERGATION_NOT_SUPPORTED | 表示方法不能运行在一个事务中，如果当前存在一个事务 则该方法将被挂起
PROPERGATION_REQUIRED | 表示该方法必须运行在事务中，如果当前存在一个事务 那么该这个方法运行在这个事务中，否则将创建一个新的事务
PROPERGATION_REQUIRED_NEW | 表示当前方法必须运行在自己的事务中，如果当前存在一个事务 那么该方法将在该方法运行期间被挂起
PROPERGATION_SUPPORTS | 表示当前方法不需要运行在一个事务中，但一个事务已经存在 该方法也可以运行在这个事务中

### 隔离级别 
- 在操作数据时可能带来了3个副作用 分别是脏读，不可重复读，幻读 为了避免这3种副作用的产生 在标准的sql中
定义了4种隔离级别 分别是 未提交读，已提交读 可重复读 和可序列化 而在Spring事务中提供了5种隔离级别来对应在
SQL中定义的4种隔离级别：

隔离级别 | 意义
---:|:---
ISOLATION_DEFAULT | 使用后端数据库默认的隔离级别
ISOLATION_READ_UNCOMMITTED | 允许读取未提交的数据(对应未提交读)，可能导致脏读，不可重复读，幻读
ISOLATION_READ_COMMITTED | 允许在一个事务中读取另一个已经提交的事务的中的数据(对应的已提交读) 可以避免脏读和不可重复读，但是不可以避免幻读
ISOLATION_REPEATABLE_READ | 一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读，可以避免脏读和不可重复读 但是无法避免幻读
ISOLATION_SERIALIZABLE | 这种隔离级别是所以的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化） 可以避免脏读，不可重复读，幻读 但是这种隔离级别效率很低 因此除非必须，否则不建议使用

### 只读
 - 如果在一个事务中所有关于数据库的操作都是只读的 也就是说，这些操作只读取数据库中的数据，而并不更新数据 那么数据应将事务设置为只读模式 这样有利于数据库优化
  因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。
  如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。
  
###事务超时
   
   如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设
   
   置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。